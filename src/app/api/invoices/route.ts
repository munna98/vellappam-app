// src/app/api/invoices/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { InvoiceStatus } from '@prisma/client'; // Make sure InvoiceStatus is imported

// GET /api/invoices
// Allows filtering by status: /api/invoices?status=PENDING
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');

    const whereClause: { status?: InvoiceStatus } = {};
    if (status && Object.values(InvoiceStatus).includes(status as InvoiceStatus)) {
      whereClause.status = status as InvoiceStatus;
    }

    const invoices = await prisma.invoice.findMany({
      where: whereClause,
      include: {
        customer: {
          select: { name: true, phone: true }, // Include customer name and phone
        },
      },
      orderBy: {
        invoiceDate: 'desc', // Order by most recent invoices first
      },
    });
    return NextResponse.json(invoices);
  } catch (error) {
    console.error('Error fetching invoices:', error);
    return NextResponse.json({ error: 'Failed to fetch invoices' }, { status: 500 });
  }
}

// POST /api/invoices (Existing code - no change needed here)
export async function POST(request: Request) {
  try {
    const { customerId, items, notes, totalAmount } = await request.json();

    // Basic validation
    if (!customerId || !Array.isArray(items) || items.length === 0 || totalAmount === undefined) {
      return NextResponse.json({ error: 'Missing required fields: customerId, items, totalAmount' }, { status: 400 });
    }

    const newInvoice = await prisma.$transaction(async (prisma) => {
      // 1. Create the new Invoice
      const invoice = await prisma.invoice.create({
        data: {
          customerId,
          totalAmount,
          notes,
          status: InvoiceStatus.PENDING, // Always starts as PENDING in this workflow
          // The invoiceNumber is auto-generated by the schema
        },
      });

      // 2. Create the InvoiceItems (line items) and link them to the invoice
      const invoiceItems = items.map((item: any) => ({
        invoiceId: invoice.id,
        productId: item.productId,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        total: item.total,
      }));

      await prisma.invoiceItem.createMany({
        data: invoiceItems,
      });

      // 3. Update the customer's balance by adding the new total amount
      await prisma.customer.update({
        where: { id: customerId },
        data: {
          balance: {
            increment: totalAmount, // Increase balance by the total invoice amount
          },
        },
      });

      return invoice;
    });

    return NextResponse.json(newInvoice, { status: 201 });
  } catch (error) {
    console.error('Error creating invoice:', error);
    return NextResponse.json({ error: 'Failed to create invoice' }, { status: 500 });
  }
}